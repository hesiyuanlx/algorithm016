学习笔记

## 重新认识java自带的PriorityQueue
1. 使用的是二分堆
2. 其remove 方法时间复杂度为O(n)并不是非常优秀的堆实现
3. 可以使用斐波那契堆进行替代（工程实现更建议使用效率更高的堆）
4. 其默认是小顶堆，需要使用lamda表达式 重写compare方法替换为大顶堆
5. new PriorityQueue<>(k, (i1, i2) -> Integer.compare(i2, i1));

## 面试遗留问题
1. 不使用新建链表，将二叉树转为双向链表的实现

## 树的理解
1. 递归的定义
2. 基于所在的三维空间，使用二维空间的树的结构比一维的数据结构拥有了更多的特性，同时带来了更快的查找方法
